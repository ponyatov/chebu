\pagebreak
\secrel{Стековая RDW-машина и язык \F}\label{rdw}

\url{https://github.com/ponyatov/RDW}

\bigskip
\begin{description}[nosep]
    \item{\term{\textbf{R}eturn stack}} стек возвратов
    \item{\term{\textbf{D}ata stack}} стек данных
    \item{\term{\textbf{W}ords} = vocabulary}, словарь
\end{description}

\bigskip\noindent Если вам интересно написать \emph{свой} язык программирования,
первым кандидатом стоит рассмотреть ваш собственный клон языка \F. Это
\textit{самый простой язык, который только можно вообразить}:
\begin{itemize}[nosep]

    \item весь синтаксис\ --- это просто \term{слова}, составленные из
    произвольных символов, разделённых пробелами: \verb|SWAP IF $#_Брр#@^ UNTIL|

    \item нет никаких управляющих структур\ --- условные блоки и циклы это такие
    же слова, слегка меняющие режим работы компилятора; если хотите, легко
    можете \term{определить} собственный вид цикла

    \item для передачи данных между словами используется общий \term{стек
    данных}\ --- слово берёт с вершины стека свои параметры, выполняет
    вычисления, и кладёт на стек результат, передавая его следующему слову в
    цепочке выполнения программы

    \item \F\ язык
    \href{https://en.wikipedia.org/wiki/Concatenative_programming_language}{конкатенативный}\note{язык
    программирования, в котором последовательные линейные фрагменты кода
    (процедура, слово) могут быть последовательно склеены в новое определение, и
    работать вместе за счёт того, что в системе есть \textit{общая для всех
    структура данных, хранящая промежуточные результаты} выполнения программы}\
    --- благодаря тому, что стек данных в \F е общий и хранит в себе данные
    независимо от выполнения форт-слов, новое слово может быть склеено из уже
    существующих, и делать что-то более сложное

\end{itemize}

\noindent
Изначально язык \F\ очень низкоуровневый: работает с целыми числами, байтами, и
адресами памяти. Поэтому \emph{программирование на \F\ --- расширение базового
языка}, определение ваших слов через уже существующие, начиная с примитивных
операций. Каждое новое слово делает всё более и более сложные вещи, при этом оно
добавляется в язык, расширяет его так как нужно лично вам. Конечно, стоит
отметить, что при этом расширяется \term{словарь} языка, но не его синтаксис: не
добавляются новые программные конструкции, это всё ещё те же слова разделённые
пробелами\note{видимо поэтому \F\ считается неудобным языком\ --- вы создаёте
новые абстракции, определяя высокоуровневые слова, но эти абстракции ``текут''
так как приходится часто обращаться к примитивным операциям; за \emph{крайнюю
простоту \textbf{реализации} языка \F}\ и его конкатенативность приходится
платить собственной дисциплиной написания кода, и его плохой читаемостью}.

Основы языка \F\ и его применение с точки зрения использования готового
интерпретатора хорошо описаны в \cite{starting,brodie}, а общая идеология языка
и ``правильные'' подходы к программированию на нём в \cite{thinking,thinkingru}.

Мы пойдём другим путём\ --- рассмотрим \F\ как технологию создания скриптовых
языков, встраиваемых в любые программы\note{написанные на высокоуровневых
mainstream языках} и системы. Например, \F\ великолепен как командная консоль
(CLI) на устройствах с микроконтроллерами\ --- собственно, он изначально для
этой задачи и создавался в 70х годах:
\begin{itemize}[nosep]
    \item минимальные требования к памяти
    \item работа через UART/serial консоль
    \item работающая версия пишется за пару недель\note{любым неопытным
    программистом, в т.ч. на ассемблере или в машинном коде}
    \item расширяемый язык позволяет произвольно усложнять протокол обмена
    данными, если вместо человека с железкой работает программа-оболочка с
    графическим интерфейсом, или сервер
\end{itemize}

\clearpage
Если точнее, мы изучим язык \F\ \textit{наизнанку}: сначала сделаем модель
\term{виртуальной \F-машины} на каком-нибудь максимально удобном и
высокоуровневом языке. Погоняем её в отладчике, концентрируясь на логике работы,
а не байтах и регистрах.
